{"componentChunkName":"component---src-templates-post-template-tsx","path":"/react-async-state-and-batching/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>React 상태 업데이트의 비동기성과 배치 처리</h2>\n<h3>상태 업데이트는 왜 비동기인가?</h3>\n<p><strong>동기적이라면?</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 만약 동기라면? 새로운 값이 찍혀야 함</span></code></pre></div>\n<p>하지만 실제로는 여전히 <strong>이전 값</strong>이 찍힌다. 이유는 React가 <strong>setState를 즉시 반영하지 않고, 업데이트 요청을 큐에 쌓기 때문</strong>이다.</p>\n<h3>React의 상태 업데이트 과정 (간단 흐름)</h3>\n<ol>\n<li><code class=\"language-text\">setState()</code> 호출 → <strong>업데이트 큐(update queue)</strong> 에 할 일 기록</li>\n<li>React는 렌더링 타이밍에 맞춰 큐를 꺼내 처리</li>\n<li>새로운 상태를 계산하고 컴포넌트를 리렌더링</li>\n</ol>\n<p>즉, <code class=\"language-text\">setState</code>는 곧바로 값을 바꾸지 않고, <strong>렌더링 예약</strong> 역할만 함</p>\n<h3>배치 처리 (Batching)</h3>\n<p>React는 효율을 위해 여러 상태 업데이트를 <strong>한 번에 합쳐서 처리</strong>한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>두 번 호출했지만, 실제 결과는 <code class=\"language-text\">+1</code></li>\n<li>이유: 두 호출 모두 같은 count 값을 기반으로 업데이트했기 때문</li>\n</ul>\n<h3>함수형 업데이트로 해결</h3>\n<p>함수형 업데이트는 항상 <strong>최신 상태(prev)</strong> 를 기준으로 계산하기 때문에 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>prev <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>prev <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 최종적으로 +2 됨</span></code></pre></div>\n<p>React는 큐를 처리할 때 <code class=\"language-text\">prev</code>를 순차적으로 업데이트하므로 원하는 결과가 나온다.</p>\n<h3>왜 비동기로 설계했을까?</h3>\n<ul>\n<li>React는 <strong>여러 업데이트를 모아서 한 번에 처리</strong>해야 성능이 좋아짐</li>\n<li>UI를 중간중간 깜빡이거나 불필요하게 여러 번 렌더링하지 않도록</li>\n<li>React 18부터는 <strong>동시성(Concurrent Rendering)</strong> 개념도 추가되어, 상태 업데이트를 더 효율적으로 스케줄링 가능</li>\n</ul>\n<h3>정리</h3>\n<ul>\n<li><code class=\"language-text\">setState</code>/<code class=\"language-text\">setCount</code>는 <strong>즉시 값이 변하지 않음</strong></li>\n<li>내부적으로 큐에 쌓이고, React가 렌더링 시점에 처리</li>\n<li>여러 업데이트는 <strong>배치(batch)</strong> 되어 한 번에 처리됨</li>\n<li>해결책: <strong>함수형 업데이트(prev => …)</strong> 를 사용해 항상 최신 상태를 기준으로 계산</li>\n</ul>","frontmatter":{"title":"React 상태 업데이트의 비동기성과 배치 처리","summary":"React에서 상태 업데이트가 비동기로 동작하는 이유와 배치 처리, 그리고 함수형 업데이트 활용법을 알아보자.","date":"2025.09.08","categories":{"type":["React"],"tags":["React"]},"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAlklEQVR42p2PwQqCQBRF/fva+jdFUJuKEBMdbGpoFwVBZquhmXQ8WdiiIAXv5j24j/Pu9ehQ4RzRKWN9zLgXZdc53j/DVdV7pucb/lziLyRhDX2psfoCcwbThOFMEBwu/YEfPUqHyjXbq8bUe6/KVRNBa81oPEGmG/ZKEScCY2xrytaE1lqk3BFGMctVQCLSGmi+nv4Cn0Kl0vnXTNsKAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/353ad/react.png","srcSet":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/21fc8/react.png 346w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/168f3/react.png 691w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/353ad/react.png 1382w","sizes":"(min-width: 1382px) 1382px, 100vw"},"sources":[{"srcSet":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/7bd2f/react.webp 346w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/a8fd0/react.webp 691w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/8aede/react.webp 1382w","type":"image/webp","sizes":"(min-width: 1382px) 1382px, 100vw"}]},"width":1382,"height":434}},"publicURL":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/react.png"}}}}]}},"pageContext":{"slug":"/react-async-state-and-batching/"}},"staticQueryHashes":[],"slicesMap":{}}