{"componentChunkName":"component---src-templates-post-template-tsx","path":"/react-memo-performance/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p><code class=\"language-text\">React.memo()</code>로 컴포넌트를 감싸면 React는 불필요한 리렌더링을 방지하기 위해 shallow comparison(얕은 비교)를 수행한다. 성능 최적화용 기술이며, React 성능 튜닝 시 반드시 이해하고 있어야 하는 개념이다.</p>\n<h3>React.memo란?</h3>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> MyComponent <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">MyComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>React.memo()는 고차 컴포넌트(HOC)이다.\nprops가 바뀌지 않았다면 컴포넌트 리렌더링을 건너뛴다.\nprops가 바뀌었는지 판단할 때 얕은 비교(shallow comparison)를 사용한다.</p>\n<br>\n<h3>shallow comparison이란?</h3>\n<p>얕은 비교는 객체의 1단계 속성만 비교하고, 내부 깊은 값까지는 확인하지 않는다.\n원시 타입 값은 그대로 비교한다.\n객체, 배열, 함수는 참조(주소)가 같아야 동일하다고 판단한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\na <span class=\"token operator\">===</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// false (내용 같아도 참조가 다름)</span>\n\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\na <span class=\"token operator\">===</span> c<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true (같은 객체 참조)</span></code></pre></div>\n<p>즉, 렌더링마다 새 객체/배열/함수를 만들어 props로 넘기면 React.memo가 소용없게 된다.</p>\n<br>\n<h3>React.memo 동작 방식</h3>\n<p>부모 컴포넌트가 리렌더링될 때 React는 이전 props와 새로운 props를 shallow compare</p>\n<ul>\n<li>같다고 판단되면 자식 컴포넌트의 렌더링을 건너뜀</li>\n<li>다르다고 판단되면 렌더링 실행</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> Child <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Child rendered\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Child</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>John<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">+</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>버튼 클릭 시 Parent는 리렌더링됨</li>\n<li>Child는 props.name이 바뀌지 않았으므로 렌더링 건너뜀</li>\n<li>콘솔에 “Child rendered”는 처음 한 번만 찍힘</li>\n</ul>\n<br>\n<h3>주의할 점</h3>\n<p><strong>1. 객체/배열/함수 props</strong></p>\n<ul>\n<li>매번 새로 생성되면 shallow compare에서 다르다고 판단 → 불필요한 리렌더링 발생</li>\n<li>해결: useMemo, useCallback으로 참조 고정</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"John\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Child</span></span> <span class=\"token attr-name\">user</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p><strong>2. custom 비교 함수 비용</strong></p>\n<ul>\n<li>React.memo(Component, areEqual) 형태로 직접 비교 함수를 줄 수 있음</li>\n<li>하지만 비교 로직이 무겁다면 성능 최적화 효과가 사라짐</li>\n</ul>\n<p><strong>3. props 비교 비용 자체</strong></p>\n<ul>\n<li>React.memo는 리렌더링을 막는 대신 props 비교 연산이 수행됨</li>\n<li>아주 단순한 컴포넌트(버튼, 단순 텍스트)에서는 오히려 이득이 거의 없음</li>\n<li>반복 렌더링되는 리스트 아이템이나 무거운 UI 컴포넌트일 때 효과 큼</li>\n</ul>\n<br>\n<h3>일반적인 React 렌더링 흐름</h3>\n<ol>\n<li>부모 컴포넌트가 리렌더링됨</li>\n<li>자식 컴포넌트도 기본적으로 다시 렌더 함수 실행</li>\n<li>새로운 Virtual DOM 생성</li>\n<li>기존 Virtual DOM과 비교(diffing)</li>\n<li>실제 DOM에 최소한의 변경만 반영</li>\n</ol>\n<p>즉, 리렌더 → Virtual DOM 생성 → diff → DOM 업데이트가 기본 흐름이다.</p>\n<br>\n<h3>React.memo가 있으면?</h3>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> Child <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">memo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Child rendered\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>props가 변하지 않았다면</p>\n<ul>\n<li>렌더 함수 실행하지 않음</li>\n<li>Virtual DOM을 새로 만들지 않음</li>\n<li>diffing &#x26; patching 과정도 없음</li>\n</ul>\n<p>➡️ 성능적으로 큰 최적화 효과를 얻을 수 있습니다.</p>\n<br>\n<h3>정리</h3>\n<p>React.memo는 props가 변하지 않으면 렌더링을 건너뛴다.</p>\n<p>얕은 비교를 사용하기 때문에 객체/배열/함수 props는 주의가 필요하다.</p>\n<p>useMemo, useCallback으로 참조를 고정하면 효과적이다.</p>\n<p>custom 비교 함수도 가능하지만 비용이 크면 역효과다.</p>\n<p>단순한 컴포넌트는 memo로 얻는 이득이 적고, 리스트·무거운 UI에서 효과가 크다.</p>\n<blockquote>\n<p>React.memo는 불필요한 리렌더링을 줄이는 강력한 도구지만, 모든 컴포넌트에 무조건 적용하는 것은 권장되지 않습니다.</p>\n<p>props 비교 비용과 컴포넌트 복잡도를 함께 고려해야 하며, 반복 렌더링되는 리스트 아이템이나 성능에 민감한 UI 컴포넌트에서 큰 효과를 발휘합니다.</p>\n</blockquote>","frontmatter":{"title":"React.memo로 성능 최적화하기","summary":"React.memo로 불필요한 리렌더링을 줄이는 방법을 알아보자.","date":"2025.09.12","categories":{"type":["React"],"tags":["React"]},"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAlklEQVR42p2PwQqCQBRF/fva+jdFUJuKEBMdbGpoFwVBZquhmXQ8WdiiIAXv5j24j/Pu9ehQ4RzRKWN9zLgXZdc53j/DVdV7pucb/lziLyRhDX2psfoCcwbThOFMEBwu/YEfPUqHyjXbq8bUe6/KVRNBa81oPEGmG/ZKEScCY2xrytaE1lqk3BFGMctVQCLSGmi+nv4Cn0Kl0vnXTNsKAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/353ad/react.png","srcSet":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/21fc8/react.png 346w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/168f3/react.png 691w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/353ad/react.png 1382w","sizes":"(min-width: 1382px) 1382px, 100vw"},"sources":[{"srcSet":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/7bd2f/react.webp 346w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/a8fd0/react.webp 691w,\n/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/8aede/react.webp 1382w","type":"image/webp","sizes":"(min-width: 1382px) 1382px, 100vw"}]},"width":1382,"height":434}},"publicURL":"/static/9ca52ecc81aa3b9cdcf283b0b7699e4e/react.png"}}}}]}},"pageContext":{"slug":"/react-memo-performance/"}},"staticQueryHashes":[],"slicesMap":{}}